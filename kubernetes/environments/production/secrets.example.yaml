apiVersion: v1
kind: Secret
metadata:
  name: app-secrets
  namespace: mankahi
type: Opaque
stringData:
  # JWT Secrets (Must be at least 64 characters long, randomly generated)
  JWT_SECRET: "replace_with_long_randomly_generated_production_key"
  JWT_ACCESS_EXPIRES_IN: "15m" # Shorter expiry for production
  JWT_REFRESH_EXPIRES_IN: "7d"
  
  # Session Secret (Must be at least 64 characters long, randomly generated)
  SESSION_SECRET: "replace_with_long_randomly_generated_production_key"
  
  # OAuth Credentials (Production credentials from Google Cloud Console)
  GOOGLE_CLIENT_ID: "replace_with_production_client_id"
  GOOGLE_CLIENT_SECRET: "replace_with_production_client_secret"
---
apiVersion: v1
kind: Secret
metadata:
  name: db-secrets
  namespace: mankahi
type: Opaque
stringData:
  # Database credentials (Use randomly generated strong passwords)
  POSTGRES_USER: "mankahi_prod"
  POSTGRES_PASSWORD: "replace_with_strong_production_password"
  POSTGRES_MULTIPLE_DATABASES: "mankahi_auth,mankahi_blog,mankahi_analytics"
---
apiVersion: v1
kind: Secret
metadata:
  name: redis-secrets
  namespace: mankahi
type: Opaque
stringData:
  # Redis URL with authentication
  REDIS_URL: "redis://:replace_with_redis_password@redis:6379"
---
apiVersion: v1
kind: Secret
metadata:
  name: minio-secrets
  namespace: mankahi
type: Opaque
stringData:
  # MinIO Production Credentials (Use strong randomly generated values)
  MINIO_ROOT_USER: "replace_with_production_minio_user"
  MINIO_ROOT_PASSWORD: "replace_with_strong_production_password"
  MINIO_ACCESS_KEY: "replace_with_production_access_key"
  MINIO_SECRET_KEY: "replace_with_production_secret_key"
---
apiVersion: v1
kind: Secret
metadata:
  name: elasticsearch-secrets
  namespace: mankahi
type: Opaque
stringData:
  # Elasticsearch Production Credentials
  ELASTICSEARCH_USERNAME: "elastic"
  ELASTICSEARCH_PASSWORD: "replace_with_strong_production_password"

# IMPORTANT SECURITY NOTES:
# 1. Never commit actual production secrets to version control
# 2. Use a secure secret management solution in production (e.g., HashiCorp Vault, AWS Secrets Manager)
# 3. Rotate all secrets regularly
# 4. Use different secrets for each environment
# 5. Monitor secret usage and implement alerting for suspicious activities
# 6. Consider using Sealed Secrets or External Secrets Operator for Kubernetes secret management

# Production Security Checklist:
# - [ ] Generate strong random secrets for all credentials
# - [ ] Set up proper authentication for Redis
# - [ ] Configure TLS for database connections
# - [ ] Set up network policies to restrict service communication
# - [ ] Enable audit logging for sensitive operations
# - [ ] Configure proper backup procedures for all secrets
# - [ ] Document secret rotation procedures
# - [ ] Set up monitoring and alerting for secret access
